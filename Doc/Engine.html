<!DOCTYPE html>
<html>

<head>
    <title>Engine Documentation</title>
    <meta charset="UTF-8">
</head>

<body>
    <div id="Summary">
        <h1>Documentation Engine</h1>
        <ul>
            <li><a href="Engine.html#Core">CoreSystem</a></li>
            <li><a href="Engine.html#Graphics">GraphicsEngine</a></li>
            <li><a href="Engine.html#Exception">Exceptions</a></li>
            <li><a href="Engine.html#GFiles">GameFiles</a></li>
            <li><a href="Engine.html#SEngine">SoundEngine</a></li>
            <li><a href="Engine.html#Menus">MenuSystem</a></li>
            <li><a href="Engine.html#DB">DataBaseSystem</a></li>
        </ul>
    </div>

    <br>

    <div id="Core">
        <h2>CoreSystem</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package comporte tout ce qui est coeur du système, à savoir Window, Timer, Keyboard et Mouse. Cliquez sur les liens suivants pour atteindre chaque documentation : </p>
        <br>
        <ul>
            <li><a href="Engine.html#Window">Window</a></li>
            <li><a href="Engine.html#Mouse">Mouse</a></li>
            <li><a href="Engine.html#Keyboard">Keyboard</a></li>
            <li><a href="Engine.html#Timer">Timer</a></li>
            <li><a href="Engine.html#JSON">JSONReader</a></li>
        </ul>

        <br>

        <div id="Window">
            <h2>Window</h2>
            <a href="Engine.html#Core">Retour au sommaire de CoreSystem</a>
            <p>La classe Window sert à gérer la fenêtre Utilisateur. Elle possède un attribut de type JFrame, de Swing permettant de générer une fenêtre. Elle est accompagnée des méthodes suivantes : </p>
            <ul>
                <li>
                    <h3>public synchronized static Window GetInstance()</h3>
                    <p>Cette méthode entre dans le cadre du patron de conception Singleton, permettant de générer un unique Objet Window dans tout le programme, atteignable partout.</p>
                    <p>Le constructeur est déclaré private pour forcer l'utilisation de cette fonction.</p>
                </li>
                <li>
                    <h3>public JFrame GetFrame()</h3>
                    <p>Getter du JFrame. Utilisé dans la classe GraphicsSystem (nous y reviendrons plus tard).</p>
                </li>
                <li>
                    <h3>public boolean ListensToEvents()</h3>
                    <p>Simple fonction booléenne qui intervient dans le cadre de la boucle de jeu. Tant que la touche ECHAP n'est pas touchée, le jeu continue. Pour fermer la fenêtre, cliquer sur la croix rouge.</p>
                </li>
            </ul>
        </div>

        <br>

        <div id="Mouse">
            <h2>Mouse</h2>
            <a href="Engine.html#Core">Retour au sommaire de CoreSystem</a>
            <p>La classe Mouse enregistre toutes les entrées liées à la souris. Elle étend les classes MouseListener, MouseWheelListener, MouseMotionListener, pour ne pas avoir à appeler leurs fonctions.</p>
            <p>Elle est accompagnée des méthodes suivantes (hors méthodes MouseListener, MouseWheelListener, MouseMotionListener) : </p>
            <ul>
                <li>
                    <h3>public synchronized static Mouse GetInstance()</h3>
                    <p>Même chose que pour Window, cette méthode entre dans le cadre du Singleton.</p>
                </li>
                <li>
                    <h3>public EventType Read()</h3>
                    <p>Permet de lire la dernière entrée souris enregistrée. Peut avoir les valeurs : LClick, LPress, LRelease, MClick, MPress, MRelease, RClick, RPress, RRelease, WheelUp, WheelDown, Move.</p>
                </li>
                <li>
                    <h3>public int GetMousePosX()</h3>
                    <p>Retourne la position X de la souris.</p>
                </li>
                <li>
                    <h3>public int GetMousePosY()</h3>
                    <p>Retourne la position Y de la souris.(Attention au sens des axes)</p>
                </li>
                <li>
                    <h3>public Point GetMousePos()</h3>
                    <p>Retourne les coordonnées XY de la souris.</p>
                </li>
                <li>
                    <h3>public boolean LeftIsPressed()</h3>
                    <p>Retourne l'état du clic gauche (pressé ou non)</p>
                </li>
                <li>
                    <h3>public boolean MiddleIsPressed()</h3>
                    <p>Retourne l'état du clic molette (pressé ou non)</p>
                </li>
                <li>
                    <h3>public boolean RightIsPressed()</h3>
                    <p>Retourne l'état du clic droit (pressé ou non)</p>
                </li>
            </ul>
        </div>

        <br>

        <div id="Keyboard">
            <h2>Keyboard</h2>
            <a href="Engine.html#Core">Retour au sommaire de CoreSystem</a>
            <p>La classe Keyboard enregistre tout ce qui est entrée clavier. Elle étend la classe KeyListener, pour ne pas avoir à appeler ses méthodes.</p>
            <p>Elle est constituée d'une classe Event constitué d'un type d'événement (Pressed, Released, None), et d'une valeur de touche (int).</p>
            <p>Elle est accompagnée des méthodes suivantes : </p>
            <ul>
                <li>
                    <h3>public synchronized static Keyboard GetInstance()</h3>
                    <p>Même chose que pour Window. Rentre dans le cadre du Singleton.</p>
                </li>
                <li>
                    <h3>public boolean KeyIsPressed(int keycode)</h3>
                    <p>Indique si la touche associée au code est pressée. Le keycode est indiqué par la classe KeyEvent.NAME (ex : KeyEvent.VK_UP pour la flèche vers le haut)</p>
                </li>
                <li>
                    <h3>public Event ReadKey()</h3>
                    <p>Permet de lire la dernière entrée clavier. Retourne le type d'entrée et la touche.</p>
                </li>
                <li>
                    <h3>public char ReadChar()</h3>
                    <p>Retourne le dernier charactère enregistré par le clavier.</p>
                </li>
                <li>
                    <h3>public boolean IsEmpty()</h3>
                    <p>Retourne vrai si le clavier n'a enregistré aucune activité. Peut être utilisé dans le cas d'une détection du mode AFK.</p>
                </li>
            </ul>
        </div>

        <br>

        <div id="Timer">
            <h2>Timer</h2>
            <a href="Engine.html#Core">Retour au sommaire de CoreSystem</a>
            <p>La classe Timer sert à calculer le temps écoulé entre chaque boucle. Très utile pour les animations.</p>
            <p>Elle est accompagnée des méthodes suivantes :</p>
            <ul>
                <li>
                    <h3>public synchronized static Timer GetInstance()</h3>
                    <p>Entre dans le cadre du Singleton.</p>
                </li>
                <li>
                    <h3>public void Update()</h3>
                    <p>Met à jour le paramètre deltaTime, temps écoulé depuis le dernier appel de Update(). IMPORTANT : une seule fonction Update() par boucle, qui est déjà implémentée dans la boucle de jeu.</p>
                </li>
                <li>
                    <h3>public float DeltaTime()</h3>
                    <p>Retourne le temps écoulé lors de la frame.</p>
                </li>
            </ul>
        </div>

        <br>

        <div id="JSON">
            <h2>JSONReader</h2>
            <a href="Engine.html#Core">Retour au sommaire de CoreSystem</a>
            <p>La classe JSONReader implémente des méthodes d'un add-on simple.JSON.</p>
            <p>Des méthodes ont été créées pour faciliter l'utilisation du parser :</p>
            <ul>
                <li>
                    <h3>public JSONReader(String path)</h3>
                    <p>Constructeur de la classe JSONReader. Permet d'ouvrir le fichier JSON (IMPORTANT : toujours enregistrer dans le dossier json)</p>
                </li>
                <li>
                    <h3>public &lt;T&gt; T GetValue(String key)</h3>
                    <p>Permet de récupérer une valeur simple enregistrée dans le JSON. Par généricité, la fonction s'adapte pour la réception de la donnée (voir dans le constructeur de Character)</p>
                </li>
                <li>
                    <h3>public TreeMap&lt;String, JSONArray&gt; GetObjectMember(String key)</h3>
                    <p>Permet d'obtenir les membres des objets JSON. Ce n'est pas utilisé souvent dans le moteur, tout est implémenté dans le constructeur de Character</p>
                </li>
            </ul>

        </div>

    </div>
    <br>

    <div id="Graphics">
        <h2>GraphicsEngine</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package comporte tout ce qui est lié à l'interface graphique. Elle est constituée des éléments suivants :</p>
        <ul>
            <li><a href="Engine.html#GraphicsSystem">GraphicsSystem</a></li>
            <li><a href="Engine.html#Sprite">Sprite</a></li>
            <li><a href="Engine.html#Animation">Animation</a></li>
        </ul>

        <br>
        <div id="GraphicsSystem">
            <h2>GraphicsSystem</h2>
            <a href="Engine.html#Graphics">Retour au sommaire de GraphicsEngine</a>
            <p>Cette classe fait partie des classes les plus importantes. En effet, tout l'affichage est géré ici. Elle étend la classe JPanel et implémente tout un lot de fonctions remplaçant les fonctions Swing.</p>
            <p>Voici les différentes méthodes (beaucoup de surcharges fonctionelles) :</p>
            <ul>
                <li>
                    <h3>public synchronized static GraphicsSystem GetInstance()</h3>
                    <p>Entre dans le cadre du Singleton.</p>
                </li>
                <li>
                    <h3>public void Render()</h3>
                    <p>Permet de rendre toute la scène. Lance toutes les fonctions enregistrées dans la boucle de jeu.</p>
                </li>
                <li>
                    <h3>public void DrawPixel(Point p, Color c)</h3>
                    <h3>public void DrawPixel(int x, int y, Color c)</h3>
                    <h3>public void DrawPixel(int x, int, y, Color c, int priority)</h3>
                    <p>Affiche un pixel de couleur c aux coordonnées (x,y) et de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawLine(Point p0, Point p1, Color c)</h3>
                    <h3>public void DrawLine(Point p0, Point p1, Color c, int priority)</h3>
                    <h3>public void DrawLine(int x0, int y0, int x1, int y1, Color c)</h3>
                    <h3>public void DrawLine(int x0, int y0, int x1, int y1, Color c, int priority)</h3>
                    <p>Dessine une ligne de couleur c entre deux points p0 et p1 et de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawRect(Rectangle r, Color c)</h3>
                    <h3>public void DrawRect(Rectangle r, Color c, int priority)</h3>
                    <h3>public void DrawRect(int x, int y, int w, int h, Color c)</h3>
                    <h3>public void DrawRect(int x, int y, int w, int h, Color c, int priority)</h3>
                    <p>Dessine les contours de couleur c d'un rectangle r, de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawFilledRect(Rectangle r, Color c)</h3>
                    <h3>public void DrawFilledRect(Rectangle r, Color c, int priority)</h3>
                    <h3>public void DrawFilledRect(int x, int y, int w, int h, Color c)</h3>
                    <h3>public void DrawFilledRect(int x, int y, int w, int h, Color c, int priority)</h3>
                    <p>Dessine un rectangle plein r de couleur c, de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawRoundRect(Rectangle r, int aw, int ah, Color c)</h3>
                    <h3>public void DrawRoundRect(Rectangle r, int aw, int ah, Color c, int priority)</h3>
                    <h3>public void DrawRoundRect(int x, int y, int w, int h, int aw, int ah, Color c)</h3>
                    <h3>public void DrawRoundRect(int x, int y, int w, int h, int aw, int ah, Color c, int priority)</h3>
                    <p>Dessine les contours de couleur c, d'un rectangle r aux bords arrondis définis par aw et ah (largeur hauteur), de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawFilledRoundRect(Rectangle r, int aw, int ah, Color c)</h3>
                    <h3>public void DrawFilledRoundRect(Rectangle r, int aw, int ah, Color c, int priority)</h3>
                    <h3>public void DrawFilledRoundRect(int x, int y, int w, int h, int aw, int ah, Color c)</h3>
                    <h3>public void DrawFilledRoundRect(int x, int y, int w, int h, int aw, int ah, Color c, int priority)</h3>
                    <p>Dessine un rectangle r aux bords arrondis définis par aw et ah (largeur hauteur), de couleur c, de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>DrawText(String text, Point p, Color c)</h3>
                    <h3>DrawText(String text, Point p, Color c, int priority)</h3>
                    <h3>DrawText(String text, int x, int y, Color c)</h3>
                    <h3>DrawText(String text, int x, int y, Color c, int priority)</h3>
                    <p>Affiche du texte à la position (x,y), de couleur c, de priorité d'affichage priority (par défaut 0)</p>
                </li>
                <li>
                    <h3>public void DrawSprite(Sprite s, Point p)</h3>
                    <h3>public void DrawSprite(Sprite s, Point p, int priority)</h3>
                    <h3>public void DrawSprite(Sprite s, int x, int y)</h3>
                    <h3>public void DrawSprite(Sprite s, int x, int y, int priority)</h3>
                    <h3>public void DrawSprite(Sprite s, Rectangle rect)</h3>
                    <h3>public void DrawSprite(Sprite s, Rectangle rect, int priority)</h3>
                    <h3>public void DrawSprite(Sprite s, int x, int y, int w, int h)</h3>
                    <h3>public void DrawSprite(Sprite s, int x, int y, int w, int h, int priority)</h3>
                    <h3>public void DrawSprite(Sprite s, Rectangle dest, Rectangle src)</h3>
                    <h3>public void DrawSprite(Sprite s, Rectangle dest, Rectangle src, int priority)</h3>
                    <h3>public void DrawSprite(Sprite s, int dx, int dy, int dw, int dh, int sx, int sy, int sw, int sh)</h3>
                    <h3>public void DrawSprite(Sprite s, int dx, int dy, int dw, int dh, int sx, int sy, int sw, int sh, int priority)</h3>
                    <p>Affiche une portion de Sprite s définie par un rectangle src, dans un rectangle dest, de priorité d'affichage priority (par défaut 0) </p>
                </li>
            </ul>
        </div>

        <br>

        <div id="Sprite">
            <h2>Sprite</h2>
            <a href="Engine.html#Graphics">Retour au sommaire de GraphicsEngine</a>
            <p>Permet de gérer les sprites. Elle est constituée des méthodes suivantes : </p>
            <br>
            <ul>
                <li>
                    <h3>public Sprite(String path)</h3>
                    <p>Constructeur de la classe. Permet d'ouvrir le fichier enregistré sur le chemin relatif pour initialiser le sprite.</p>
                </li>
                <li>
                    <h3>public Image GetSprite()</h3>
                    <p>Retourne le sprite intialisé. Utilisé pour la méthode DrawSprite() de GraphicsSystem</p>
                </li>
                <li>
                    <h3>public int GetWidth()</h3>
                    <p>Retourne la largeur du sprite</p>
                </li>
                <li>
                    <h3>public int GetHeight()</h3>
                    <p>Retourne la hauteur du sprite.</p>
                </li>
            </ul>
        </div>

        <br>

        <div id="Animation">
            <h2>Animation</h2>
            <a href="Engine.html#Graphics">Retour au sommaire de GraphicsEngine</a>
            <p>Permet de gérer les différentes animations. On utilise un sprite un peu particulier appelé SpriteSheet, qui possède toutes les images des animations.</p>
            <p>Elle est constituée des méthodes suivantes : </p>
            <br>
            <ul>
                <li>
                    <h3>public Animation(Rectangle rect, int count, Sprite _s, float _holdTime)</h3>
                    <p>Constructeur de la classe. Initilise les différents découpages pour l'animation.</p>
                    <p>Rect représente les dimensions d'une image, count le nombre d'images, et holdTime le temps d'apparition d'une image</p>
                </li>
                <li>
                    <h3>public void Update()</h3>
                    <p>Met à jour l'animation en fonction du temps (issu de <a>CoreSystem.Timer</a>)</p>
                </li>
                <li>
                    <h3>public void Draw(Rectangle dest)</h3>
                    <p>Permet d'afficher l'image en cours dans l'animation.</p>
                </li>
            </ul>
        </div>

    </div>

    <br>

    <div id="Exception">
        <h2>Exceptions</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package contient une unique classe ProjectException. Elle étend la classe Exception, et est accompagnée de la méthode suivante : </p>
        <h3>public static void ShowMessageBox(Exception e, String title)</h3>
        <p>Utilisé dans les try-catch dans la classe Main</p>
    </div>

    <br>

    <div id="GFiles">
        <h2>GameFiles</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package regroupe toutes les classes liées au jeu. Elle est constituée de la classe Game (boucle de jeu), et des différentes classes à développer plus tard.</p>
        <p>Voici les différentes classes ajoutées :</p>
        <ul>
            <li><a href="Engine.html#Game">Game</a></li>
            <li><a href="Engine.html#Character">Character</a></li>
        </ul>

        <br>

        <div id="Game">
            <h2>Game</h2>
            <a href="Engine.html#GFiles">Retour au sommaire de GameFiles</a>
            <p>Classe principale du moteur, c'est ici que se déroule la boucle de jeu. Elle est constitué des 2 méthodes suivantes (appelées toutes deux dans une méthode publique) : </p>
            <ul>
                <li>
                    <h3>public void Go()</h3>
                    <p>La boucle de jeu. Appelle les deux fontions importantes.</p>
                </li>
                <li>
                    <h3>private void UpdateFrame()</h3>
                    <p>Là où se déroulent tous les calculs pour la frame en cours. Aucun affichage n'est fait ici.</p>
                </li>
                <li>
                    <h3>private void RenderFrame()</h3>
                    <p>Là où se déroule l'affichage. Aucun calcul n'est fait ici.</p>
                </li>
            </ul>
        </div>

        <div id="Character">

            <h2>Character</h2>
            <a href="Engine.html#GFiles">Retour au sommaire de GameFiles</a>
            <p>Classe ajoutée pour montrer le potentiel du moteur, peut être utilisée pour n'importe quel personnage. méthodes :</p>
            <ul>
                <li>
                    <h3>public Character(Rectangle _rect, String spriteFile)</h3>
                    <p>Constructeur. On entre en paramètres le rectangle d'écriture (première position), et le nom du fichier (le sprite)</p>
                </li>
                <li>
                    <h3>public void Update()</h3>
                    <p>Gestion de tous les calculs concernant Character. Dans le cas de la démo, on s'occupe de l'Animation et des déplacements.</p>
                </li>
                <li>
                    <h3>public void Draw()</h3>
                    <p>Gestion de l'affichage de l'Animation.</p>
                </li>
            </ul>
        </div>


    </div>

    <br>

    <div id="SEngine">
        <h2>SoundEngine</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package contient une unique classe SoundEngine, permettant de jouer des musiques. Toutefois, il faut rester vigilant avec cette classe, car durant les tests le jeu peut parfois rester figé (j'ai tenté de régler avec un délai, mais il faudra
            faire plus de tests pour vérifier la récurrence du bug)</p>
        <p>Voici les méthodes proposées par la classe SoundSystem :</p>
        <ul>
            <li>
                <h3>public synchronized static SoundSystem GetInstance()</h3>
                <p>Entre dans le cadre du Singleton (peut être à modifier plus tard)</p>
            </li>
            <li>
                <h3>public void SelectNewSong(String path)</h3>
                <p>Permet d'ouvrir un fichier musical</p>
            </li>
            <li>
                <h3>public void PlaySong()</h3>
                <p>Permet de jouer le son enregistré via le SelectNewSong()</p>
            </li>
            <li>
                <h3>public void PauseSong()</h3>
                <p>Permet de mettre en pause le son en jeu.</p>
            </li>
            <li>
                <h3>public void ResumeSong()</h3>
                <p>Permet de reprendre le son après la pause (fonction à vérifier car cause un gel)</p>
            </li>
            <li>
                <h3>public void StopSong()</h3>
                <p>Permet d'arrêter le son en jeu</p>
            </li>
            <li>
                <h3>public void RestartSong()</h3>
                <p>Permet de rejouer le son depuis le début</p>
            </li>
        </ul>

    </div>

    <br>

    <div id="Menus">
        <h2>MenuSystem</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce package permet de créer des menus.</p>
        <p>Chaque menu étend la classe MenuDecorator, et utilise le principe du patron de conception <a href="https://fr.wikibooks.org/wiki/Patrons_de_conception/Décorateur">Décorateur</a>.</p>
        <p>Cela permet une création rapide des Menus, seul le constructeur est modifié pour chaque menu, rendant la création de Menu rapide (un menu en 2 min facilement, permet également de faire des associations de menu)</p>
        <p>Le package comporte les classes suivantes :</p>
        <ul>
            <li><a href="Engine.html#IMenu">IMenu</a></li>
            <li><a href="Engine.html#Lambda">Lambda</a></li>
            <li><a href="Engine.html#BasicMenu">BasicMenu</a></li>
            <li><a href="Engine.html#MenuDecorator">MenuDecorator</a></li>
            <li><a href="Engine.html#Button">Button</a></li>
            <li><a href="Engine.html#TextBox">TextBox</a></li>
            <li><a href="Engine.html#MenuTest">MenuTest</a></li>
        </ul>

        <br>

        <div id="IMenu">
            <h2>IMenu</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Il s'agit d'une interface où sont définies toutes les fonctions propres aux menus, qui sont les suivantes :</p>
            <ul>
                <li>
                    <h3>public abstract void Update()</h3>
                    <h3>public abstract void Update(CoreSystem.Mouse.EventType e)</h3>
                    <p>Permet de mettre à jour le menu. Surcharge fonctionnelle pour les menus décorés (dans le cas d'un clic de la souris)</p>
                </li>
                <li>
                    <h3>public abstract void Draw()</h3>
                    <p>Permet d'afficher tout ce qui compose un menu</p>
                </li>
            </ul>
        </div>

        <div id="Lambda">
            <h2>Lambda</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Il s'agit d'une interface permettant l'enregistrement de fonctions nommées Lambda. Dans notre cas, les fonctions n'ont pas de paramètres, mais on peut modifier à tout moment les fonctions (et éventuellement utiliser la généricité pour cela)</p>
            <p>Une unique méthode : </p>
            <h3>public abstract func()</h3>
        </div>

        <div id="BasicMenu">
            <h2>BasicMenu</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Menu vide. Indispensable pour l'initialisation des menus pour faire le menu décoré de fin.</p>
            <p>Toutes les méthodes sont celles de <a href="Engine.html#IMenu">IMenu</a></p>
        </div>

        <div id="MenuDecorator">
            <h2>MenuDecorator</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Classe permettant la décoration des menus. Implémente l'interface IMenu. Tous les menus futurs étendent cette classe.</p>
            <p>Toutes les méthodes sont celles de <a href="Engine.html#IMenu">IMenu</a>, sauf une : </p>
            <h3>protected void InitializeButtonsAndTextBoxes(HashMap&lt;Rectangle, Map.Entry&lt;String, Lambda&gt;&gt; _buttons, HashMap&lt;Rectangle, String&gt; _textBoxes)</h3>
            <p>Méthode uniquement accessible par les enfants de MenuDecorateur. Permet d'initialiser les différents boutons et textbox composant le menu. Les paramètres sont des tableaux à triple entrées et à double entrées.</p>
        </div>

        <div id="Button">
            <h2>Button</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Classe permettant de définir un bouton. Le bouton est cliquable, et on peut passer dessus.</p>
            <p>Les différentes méthodes :</p>
            <ul>
                <li>
                    <h3>public Button(Rectangle _rect, String _text, Lambda _func)</h3>
                    <p>Constructeur du bouton. Associe un rectangle, un texte et une fonction à exécuter</p>
                </li>
                <li>
                    <h3>public boolean OnClick()</h3>
                    <p>Retourne vrai en cas de clic Souris</p>
                </li>
                <li>
                    <h3>public boolean OnHover()</h3>
                    <p>Retourne vrai en cas de survol Souris</p>
                </li>
                <li>
                    <h3>public void ComputeFunction()</h3>
                    <p>Exécute la fonction enregistrée dans le constructeur</p>
                </li>
                <li>
                    <h3>public void Draw(Color c)</h3>
                    <p>Affiche le bouton à l'écran (text + rectangle plein de couleur c)</p>
                </li>
                <li>
                    <h3>public boolean IsClicked()</h3>
                    <p>Retourne l'état du bouton (cliqué ou pas cliqué)</p>
                </li>
            </ul>
        </div>

        <div id="TextBox">
            <h2>TextBox</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Classe permettant de définir une boîte de texte.</p>
            <p>Les différentes méthodes : </p>
            <ul>
                <li>
                    <h3>public TextBox(Rectangle _rect)</h3>
                    <h3>public TextBox(Rectangle _rect, _text)</h3>
                    <p>Différents constructeurs d'une TextBox, en fonction de ce que l'on veut (texte dynamique ou statique)</p>
                </li>
                <li>
                    <h3>public void Draw(Color textColor, Color boxColor, Color backgroundColor)</h3>
                    <h3>public void Draw(String _text, Color textColor, Color boxColor, Color backgroundColor)</h3>
                    <p>Différentes méthodes d'affichage, en fonction de ce qu'on a (texte dynamique ou statique)</p>
                </li>
            </ul>
        </div>

        <div id="MenuTest">
            <h2>MenuTest</h2>
            <a href="Engine.html#Menus">Retour au sommaire de MenuSystem</a>
            <p>Classe de démo pour les menus.</p>
            <p>Seul le constructeur est ajouté, vous pouvez étudier le code. La syntaxe est toujours la même.</p>
        </div>

    </div>

    <br>

    <div id="DB">
        <h2>DataBaseSystem</h2>
        <a href="Engine.html#Summary">Retour au sommaire</a>
        <p>Ce module est à tester impérativement. Pour le moment je n'ai pas réussi à le tester car MySQL Workbench ne veut pas ouvrir de script SQL. Mais vous pouvez essayer si ça fonctionne chez vous.</p>
        <p>Ce package ne comporte qu'une seule classe : DataBaseManager</p>
        <p>Voici les méthodes de DataBaseManager : </p>
        <ul>
            <li>
                <h3>public DataBaseManager(String databaseName, String password)</h3>
                <p>Constructeur de la classe. Permet de se connecter à une base de données en connaissant son nom et le mot de passe d'entrée</p>
            </li>
            <li>
                <h3>public ResultSet GetResultFromSQLRequest(String request)</h3>
                <p>Retourne un ResultSet après une requête SQL (nécessite de connaître les requêtes SQL pour que cela fonctionne)</p>
            </li>
            <li>
                <h3>public void SendSDLRequest(String request)</h3>
                <p>Permet d'envoyer une requête à la base de données (utilisé pour l'écriture notamment, ou la suppression de tables. Même chose que pour la méthode précédente, nécessaire de connaître les requêtes SQL)</p>
            </li>
            <li>
                <h3>public ArrayList&lt;ArrayList&lt;Object&gt;&gt; GetArrayFrom(ResultSet rs)</h3>
                <p>Permet de récupérer le tableau associé au résultat des requêtes. ArrayList d'ArrayList car on ne peut pas traîter autant de données avec une Map (double entrée contre une multitude avec le ArrayList d'ArrayList)</p>
                <p>Voici un exemple de code pour l'utilisation:</p>
                <div>
                    <i>DataBaseSystem.DataBaseManager dbm = new DataBaseSystem.DataBaseManager("test", "password123");<br> ArrayList&lt;ArrayList&lt;Object&gt;&gt; result = dbm.GetArrayFrom(dbm.GetResultFromSQLRequest("SELECT id, first, last, age
                    FROM Registration"));
                    </i>
                </div>
            </li>
        </ul>

    </div>

</body>

</html>